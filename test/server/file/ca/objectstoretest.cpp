/**
  *  \file test/server/file/ca/objectstoretest.cpp
  *  \brief Test for server::file::ca::ObjectStore
  */

#include "server/file/ca/objectstore.hpp"

#include "afl/except/fileproblemexception.hpp"
#include "afl/string/format.hpp"
#include "afl/test/testrunner.hpp"
#include "server/file/internaldirectoryhandler.hpp"
#include <memory>
#include <stdexcept>
#include "afl/io/internaldirectory.hpp"
#include "afl/io/constmemorystream.hpp"

using afl::base::Ref;
using afl::io::ConstMemoryStream;
using afl::io::FileMapping;
using afl::io::InternalDirectory;
using server::file::DirectoryHandler;
using server::file::ca::ObjectId;
using server::file::ca::ObjectStore;

namespace {
    // A counting DirectoryHandler
    class CountingDirectoryHandler : public DirectoryHandler {
     public:
        CountingDirectoryHandler(size_t& count, std::auto_ptr<DirectoryHandler> impl)
            : m_count(count),
              m_impl(impl)
            { }
        virtual String_t getName()
            { return m_impl->getName(); }
        virtual afl::base::Ref<afl::io::FileMapping> getFile(const Info& info)
            {
                ++m_count;
                return m_impl->getFile(info);
            }
        virtual afl::base::Ref<afl::io::FileMapping> getFileByName(String_t name)
            {
                ++m_count;
                return m_impl->getFileByName(name);
            }
        virtual Info createFile(String_t name, afl::base::ConstBytes_t content)
            { return m_impl->createFile(name, content); }
        virtual void removeFile(String_t name)
            { m_impl->removeFile(name); }
        virtual afl::base::Optional<Info> copyFile(ReadOnlyDirectoryHandler& source, const Info& sourceInfo, String_t name)
            { return m_impl->copyFile(source, sourceInfo, name); }
        virtual void readContent(Callback& callback)
            { m_impl->readContent(callback); }
        virtual DirectoryHandler* getDirectory(const Info& info)
            {
                std::auto_ptr<DirectoryHandler> child(m_impl->getDirectory(info));
                return new CountingDirectoryHandler(m_count, child);
            }
        virtual Info createDirectory(String_t name)
            { return m_impl->createDirectory(name); }
        virtual void removeDirectory(String_t name)
            { m_impl->removeDirectory(name); }
        virtual SnapshotHandler* getSnapshotHandler()
            { return m_impl->getSnapshotHandler(); }
        virtual afl::base::Ptr<afl::io::Directory> getDirectory()
            { return m_impl->getDirectory(); }
     private:
        size_t& m_count;
        std::auto_ptr<DirectoryHandler> m_impl;
    };
}



/** Test getObject(), getObjectSize(). */
AFL_TEST("server.file.ca.ObjectStore:getObject", a)
{
    // A tree object
    static const uint8_t OBJ[] = {
        0x78, 0x01, 0x2b, 0x29, 0x4a, 0x4d, 0x55, 0x30, 0x36, 0x62, 0x30, 0x34,
        0x30, 0x30, 0x33, 0x31, 0x51, 0x48, 0xcb, 0xcc, 0x49, 0x65, 0x70, 0x10,
        0xd1, 0xe5, 0x3c, 0xae, 0xad, 0xa3, 0x1a, 0xce, 0x3d, 0xc3, 0x80, 0x47,
        0xfd, 0xc6, 0x9c, 0xf0, 0xb7, 0xc2, 0xba, 0x00, 0xd7, 0x51, 0x0b, 0x47
    };
    static const ObjectId OBJID = {{0x39,0x7b,0xbf,0x05,0x97,0x39,0xcb,0xfa,0x73,0xaa,0xd2,0xf8,0xbf,0x40,0x4d,0x04,0xf4,0x78,0xb3,0x8a}};

    // Create test setup
    server::file::InternalDirectoryHandler::Directory rootDir("");
    server::file::InternalDirectoryHandler rootHandler("root", rootDir);
    server::file::DirectoryHandler::Info subInfo = rootHandler.createDirectory("39");

    std::auto_ptr<server::file::DirectoryHandler> subHandler(rootHandler.getDirectory(subInfo));
    subHandler->createFile("7bbf059739cbfa73aad2f8bf404d04f478b38a", OBJ);

    // Test existing object
    {
        ObjectStore testee(rootHandler);
        afl::base::Ref<afl::io::FileMapping> result = testee.getObject(OBJID, testee.TreeObject);
        a.checkEqual("01. get", result->get().size(), 32U);

        static const uint8_t EXPECTED[] = {
            0x31, 0x30, 0x30, 0x36, 0x34, 0x34, 0x20, 0x66, 0x69, 0x6c, 0x65, 0x00, 0x40, 0x14, 0x2d, 0x09,
            0xc7, 0x2b, 0x2c, 0x25, 0x57, 0x0b, 0x98, 0x30, 0x0c, 0x27, 0xd8, 0x9c, 0x57, 0xed, 0x13, 0x2d
        };
        a.checkEqualContent<uint8_t>("02. content", result->get(), EXPECTED);
    }
    {
        ObjectStore testee(rootHandler);
        a.checkEqual("11. getObjectSize", testee.getObjectSize(OBJID, testee.TreeObject), 32U);
    }

    // Existing with wrong type
    {
        ObjectStore testee(rootHandler);
        AFL_CHECK_THROWS(a("21. getObjectSize wrong type"), testee.getObjectSize(OBJID, testee.DataObject), std::runtime_error);
        AFL_CHECK_THROWS(a("22. getObject wrong type"),     testee.getObject(OBJID, testee.DataObject), std::runtime_error);
    }

    // Test null object
    {
        ObjectStore testee(rootHandler);
        a.checkEqual("31. getObjectSize null", testee.getObjectSize(ObjectId::nil, testee.DataObject), 0U);
        a.checkEqual("32. getObjectSize null", testee.getObjectSize(ObjectId::nil, testee.TreeObject), 0U);
        a.checkEqual("33. getObjectSize null", testee.getObjectSize(ObjectId::nil, testee.CommitObject), 0U);

        a.checkEqual("41. getObject null", testee.getObject(ObjectId::nil, testee.DataObject)->get().size(), 0U);
        a.checkEqual("42. getObject null", testee.getObject(ObjectId::nil, testee.TreeObject)->get().size(), 0U);
        a.checkEqual("43. getObject null", testee.getObject(ObjectId::nil, testee.CommitObject)->get().size(), 0U);
    }

    // Non-existant
    {
        static const ObjectId OBJID1 = {{0x39,0x7b,0xbf,0x05,0x97,0x39,0xcb,0xfa,0x73,0xff,0xff,0xff,0xbf,0x40,0x4d,0x04,0xf4,0x78,0xb3,0x8a}};
        static const ObjectId OBJID2 = {{0x38,0xff,0xff,0x05,0x97,0x39,0xcb,0xfa,0x73,0xff,0xff,0xff,0xbf,0x40,0x4d,0x04,0xf4,0x78,0xb3,0x8a}};
        ObjectStore testee(rootHandler);
        AFL_CHECK_THROWS(a("51. getObjectSize missing"), testee.getObjectSize(OBJID1, testee.DataObject), afl::except::FileProblemException);
        AFL_CHECK_THROWS(a("52. getObjectSize missing"), testee.getObjectSize(OBJID2, testee.DataObject), afl::except::FileProblemException);
        AFL_CHECK_THROWS(a("53. getObject missing"),     testee.getObject(OBJID1, testee.DataObject), afl::except::FileProblemException);
        AFL_CHECK_THROWS(a("54. getObject missing"),     testee.getObject(OBJID2, testee.DataObject), afl::except::FileProblemException);
    }
}

/** Test addObject(). */
AFL_TEST("server.file.ca.ObjectStore:addObject", a)
{
    // Create test setup
    server::file::InternalDirectoryHandler::Directory rootDir("");
    server::file::InternalDirectoryHandler rootHandler("root", rootDir);

    // Add an object
    static const uint8_t CONTENT[] = {
        0x31, 0x30, 0x30, 0x36, 0x34, 0x34, 0x20, 0x66, 0x69, 0x6c, 0x65, 0x00, 0x40, 0x14, 0x2d, 0x09,
        0xc7, 0x2b, 0x2c, 0x25, 0x57, 0x0b, 0x98, 0x30, 0x0c, 0x27, 0xd8, 0x9c, 0x57, 0xed, 0x13, 0x2d
    };
    static const ObjectId OBJID = {{0x39,0x7b,0xbf,0x05,0x97,0x39,0xcb,0xfa,0x73,0xaa,0xd2,0xf8,0xbf,0x40,0x4d,0x04,0xf4,0x78,0xb3,0x8a}};
    {
        // Add the object
        ObjectStore testee(rootHandler);
        ObjectId id = testee.addObject(testee.TreeObject, CONTENT);
        a.checkEqual("01. addObject", id, OBJID);

        // Adding the same object is not an error
        AFL_CHECK_SUCCEEDS(a("11. addObject again"), testee.addObject(testee.TreeObject, CONTENT));
    }
    {
        // Retrieve the object again
        ObjectStore testee(rootHandler);
        afl::base::Ref<afl::io::FileMapping> result = testee.getObject(OBJID, testee.TreeObject);
        a.checkEqual("12. getObject", result->get().size(), 32U);

        static const uint8_t EXPECTED[] = {
            0x31, 0x30, 0x30, 0x36, 0x34, 0x34, 0x20, 0x66, 0x69, 0x6c, 0x65, 0x00, 0x40, 0x14, 0x2d, 0x09,
            0xc7, 0x2b, 0x2c, 0x25, 0x57, 0x0b, 0x98, 0x30, 0x0c, 0x27, 0xd8, 0x9c, 0x57, 0xed, 0x13, 0x2d
        };
        a.checkEqualContent<uint8_t>("13. content", result->get(), EXPECTED);
    }

    // Add some more objects
    // "000" -> fd594a59b16db3e1f6fec8f05f703765a000bdb7 (exercises "make new directory" path)
    // "170" -> 3968aef87f28b2029667d95cd6e22f31b0bd2e50 (exercises "use existing directory" path)
    static const uint8_t CONTENT_NEW[] = {'0','0','0'};
    static const uint8_t CONTENT_SAME[] = {'1','7','0'};
    static const ObjectId OBJID_NEW =  {{0xfd,0x59,0x4a,0x59,0xb1,0x6d,0xb3,0xe1,0xf6,0xfe,0xc8,0xf0,0x5f,0x70,0x37,0x65,0xa0,0x00,0xbd,0xb7}};
    static const ObjectId OBJID_SAME = {{0x39,0x68,0xae,0xf8,0x7f,0x28,0xb2,0x02,0x96,0x67,0xd9,0x5c,0xd6,0xe2,0x2f,0x31,0xb0,0xbd,0x2e,0x50}};
    {
        ObjectStore testee(rootHandler);
        a.checkEqual("21. addObject", testee.addObject(testee.DataObject, CONTENT_NEW), OBJID_NEW);
        a.checkEqual("22. addObject", testee.addObject(testee.DataObject, CONTENT_SAME), OBJID_SAME);
    }

    // Adding same content with different type produces different ID
    {
        ObjectStore testee(rootHandler);
        a.checkDifferent("31. addObject Tree",   testee.addObject(testee.TreeObject, CONTENT_NEW), OBJID_NEW);
        a.checkDifferent("32. addObject Commit", testee.addObject(testee.CommitObject, CONTENT_NEW), OBJID_NEW);
    }

    // Can still retrieve original objects
    {
        ObjectStore testee(rootHandler);
        afl::base::Ref<afl::io::FileMapping> result = testee.getObject(OBJID_NEW, testee.DataObject);
        a.check("41. getObject", result->get().equalContent(CONTENT_NEW));
    }
}

/** Test storage/retrieval of large objects. */
AFL_TEST("server.file.ca.ObjectStore:addObject:large", a)
{
    // Create test setup
    server::file::InternalDirectoryHandler::Directory rootDir("");
    server::file::InternalDirectoryHandler rootHandler("root", rootDir);

    // Create a huge object
    // This is 80k that compress down to about 20k.
    afl::base::GrowableMemory<uint8_t> obj;
    for (int i = 0; i < 10000; ++i) {
        obj.append(afl::string::toBytes(afl::string::Format("%07d\n", i)));
    }
    a.checkEqual("01. size", obj.size(), 80000U);

    // Store object
    ObjectId id = ObjectStore(rootHandler).addObject(ObjectStore::DataObject, obj);

    // Retrieve object
    afl::base::Ref<afl::io::FileMapping> result = ObjectStore(rootHandler).getObject(id, ObjectStore::DataObject);
    a.checkEqual("11. get", result->get().size(), obj.size());
    a.checkEqualContent<uint8_t>("12. content", result->get(), obj);
}

/** Test cache effectiveness. */
AFL_TEST("server.file.ca.ObjectStore:cache", a)
{
    // Create test setup
    ObjectId aa, bb, cc;
    server::file::InternalDirectoryHandler::Directory rootDir("");
    {
        // Preload some files
        server::file::InternalDirectoryHandler rootHandler("root", rootDir);
        ObjectStore testee(rootHandler);
        aa = testee.addObject(ObjectStore::DataObject, afl::string::toBytes("alpha"));
        bb = testee.addObject(ObjectStore::DataObject, afl::string::toBytes("bravo"));
        cc = testee.addObject(ObjectStore::DataObject, afl::string::toBytes("charlie"));
    }

    // Test sequence
    size_t count = 0;
    CountingDirectoryHandler rootCounter(count, std::auto_ptr<DirectoryHandler>(new server::file::InternalDirectoryHandler("root", rootDir)));
    ObjectStore testee(rootCounter);

    // Add some more files
    ObjectId dd = testee.addObject(ObjectStore::DataObject, afl::string::toBytes("delta"));
    ObjectId ee = testee.addObject(ObjectStore::DataObject, afl::string::toBytes("echo"));
    ObjectId ff = testee.addObject(ObjectStore::DataObject, afl::string::toBytes("foxtrot"));

    // Retrieve these files repeatedly
    for (int i = 0; i < 100; ++i) {
        AFL_CHECK_SUCCEEDS(a("01. getObject aa"), testee.getObject(aa, ObjectStore::DataObject));
        AFL_CHECK_SUCCEEDS(a("02. getObject bb"), testee.getObject(bb, ObjectStore::DataObject));
        AFL_CHECK_SUCCEEDS(a("03. getObject cc"), testee.getObject(cc, ObjectStore::DataObject));
        AFL_CHECK_SUCCEEDS(a("04. getObject dd"), testee.getObject(dd, ObjectStore::DataObject));
        AFL_CHECK_SUCCEEDS(a("05. getObject ee"), testee.getObject(ee, ObjectStore::DataObject));
        AFL_CHECK_SUCCEEDS(a("06. getObject ff"), testee.getObject(ff, ObjectStore::DataObject));

        a.checkEqual("11. getObjectSize aa", testee.getObjectSize(aa, ObjectStore::DataObject), 5U);
        a.checkEqual("12. getObjectSize bb", testee.getObjectSize(bb, ObjectStore::DataObject), 5U);
        a.checkEqual("13. getObjectSize cc", testee.getObjectSize(cc, ObjectStore::DataObject), 7U);
        a.checkEqual("14. getObjectSize dd", testee.getObjectSize(dd, ObjectStore::DataObject), 5U);
        a.checkEqual("15. getObjectSize ee", testee.getObjectSize(ee, ObjectStore::DataObject), 4U);
        a.checkEqual("16. getObjectSize ff", testee.getObjectSize(ff, ObjectStore::DataObject), 7U);
    }

    // Check count
    a.check("21. count", count > 0);
    a.check("22. count", count < 10);
}

/** Test caching, size requests only.
    This is the same as above, but asks for sizes only. */
AFL_TEST("server.file.ca.ObjectStore:cache:size", a)
{
    // Create test setup
    ObjectId aa, bb, cc;
    server::file::InternalDirectoryHandler::Directory rootDir("");
    {
        // Preload some files
        server::file::InternalDirectoryHandler rootHandler("root", rootDir);
        ObjectStore testee(rootHandler);
        aa = testee.addObject(ObjectStore::DataObject, afl::string::toBytes("alpha"));
        bb = testee.addObject(ObjectStore::DataObject, afl::string::toBytes("bravo"));
        cc = testee.addObject(ObjectStore::DataObject, afl::string::toBytes("charlie"));
    }

    // Test sequence
    size_t count = 0;
    CountingDirectoryHandler rootCounter(count, std::auto_ptr<DirectoryHandler>(new server::file::InternalDirectoryHandler("root", rootDir)));
    ObjectStore testee(rootCounter);

    // Add some more files
    ObjectId dd = testee.addObject(ObjectStore::DataObject, afl::string::toBytes("delta"));
    ObjectId ee = testee.addObject(ObjectStore::DataObject, afl::string::toBytes("echo"));
    ObjectId ff = testee.addObject(ObjectStore::DataObject, afl::string::toBytes("foxtrot"));

    // Retrieve these files repeatedly
    for (int i = 0; i < 100; ++i) {
        a.checkEqual("01. getObjectSize aa", testee.getObjectSize(aa, ObjectStore::DataObject), 5U);
        a.checkEqual("02. getObjectSize bb", testee.getObjectSize(bb, ObjectStore::DataObject), 5U);
        a.checkEqual("03. getObjectSize cc", testee.getObjectSize(cc, ObjectStore::DataObject), 7U);
        a.checkEqual("04. getObjectSize dd", testee.getObjectSize(dd, ObjectStore::DataObject), 5U);
        a.checkEqual("05. getObjectSize ee", testee.getObjectSize(ee, ObjectStore::DataObject), 4U);
        a.checkEqual("06. getObjectSize ff", testee.getObjectSize(ff, ObjectStore::DataObject), 7U);
    }

    // Check count
    a.check("11. count", count > 0);
    a.check("12. count", count < 10);
}

/** Test packfile handling. */
AFL_TEST("server.file.ca.ObjectStore:packfile", a)
{
    // OBJ_REF_DELTA testcase from PackFileTest
    const uint8_t REF_INDEX_FILE[] = {
        0xff, 0x74, 0x4f, 0x63, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02,
        0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02,
        0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02,
        0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02,
        0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02,
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03,
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x06,
        0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x06,
        0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x06,
        0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x06,
        0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x06,
        0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x06,
        0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x06, 0x16, 0x8d, 0x29, 0x2b, 0x86, 0x9f, 0xe7, 0xf2,
        0xc6, 0x5f, 0xfe, 0xdc, 0x32, 0x40, 0x44, 0x81, 0xc6, 0x80, 0x1e, 0x37, 0x7f, 0x54, 0x31, 0xe3,
        0x9f, 0xfd, 0xb5, 0x33, 0x16, 0x48, 0xc3, 0x65, 0xc1, 0x7b, 0x2b, 0xe4, 0xf8, 0xb8, 0x7a, 0x51,
        0x92, 0x14, 0x39, 0x54, 0x27, 0xde, 0x27, 0x89, 0x35, 0x1d, 0x17, 0x4f, 0xa1, 0x37, 0x90, 0x5d,
        0xe1, 0x94, 0x50, 0xa6, 0x97, 0xf9, 0x30, 0x64, 0xd4, 0x7d, 0x3a, 0x24, 0xda, 0x81, 0x7a, 0xfd,
        0xbd, 0x6b, 0xe4, 0x01, 0x13, 0x95, 0x82, 0xe2, 0xe8, 0xd3, 0x43, 0x02, 0x23, 0x40, 0xb6, 0xf7,
        0x3f, 0x6b, 0xf6, 0x90, 0x51, 0x2c, 0x4c, 0x8c, 0x6b, 0x2e, 0x0f, 0x19, 0xe9, 0x5d, 0x7f, 0x96,
        0x43, 0xd2, 0x7f, 0x0d, 0xf5, 0x59, 0xb5, 0x0d, 0x6d, 0xc8, 0x44, 0xa1, 0x2f, 0xb9, 0xe4, 0xae,
        0xeb, 0xd6, 0x75, 0xc5, 0x6f, 0xca, 0xb9, 0x61, 0x7d, 0x97, 0xf3, 0xca, 0x06, 0x3a, 0x3a, 0x10,
        0x15, 0xd7, 0x99, 0x1c, 0xea, 0x84, 0xe2, 0xed, 0x00, 0x00, 0x02, 0xea, 0x00, 0x00, 0x02, 0x8c,
        0x00, 0x00, 0x00, 0xa4, 0x00, 0x00, 0x01, 0x21, 0x00, 0x00, 0x02, 0xbb, 0x00, 0x00, 0x00, 0x0c,
        0xac, 0xf4, 0x5e, 0x7e, 0x44, 0x80, 0xd9, 0x85, 0x2d, 0x9a, 0xf3, 0x28, 0xc3, 0x01, 0x25, 0x56,
        0x76, 0xac, 0x28, 0xa4, 0x07, 0x14, 0xab, 0x99, 0xab, 0x9c, 0xb5, 0x27, 0x4b, 0xd0, 0x76, 0xb4,
        0xb5, 0x3b, 0xbe, 0x2e, 0x06, 0x67, 0x7a, 0x52
    };
    const uint8_t REF_PACK_FILE[] = {
        0x50, 0x41, 0x43, 0x4b, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x06, 0x9c, 0x0d, 0x78, 0x9c,
        0x95, 0xcc, 0x41, 0x0e, 0xc2, 0x20, 0x10, 0x40, 0xd1, 0x3d, 0xa7, 0x98, 0xbd, 0x89, 0x61, 0x60,
        0x86, 0x81, 0xc4, 0x18, 0xcf, 0x60, 0x4f, 0x00, 0x65, 0x50, 0x17, 0x6d, 0x0d, 0xd2, 0xc4, 0xe3,
        0x6b, 0xe2, 0x09, 0x5c, 0xfe, 0xc5, 0xfb, 0xa3, 0xab, 0x82, 0x34, 0x26, 0x8f, 0xea, 0x53, 0x6b,
        0xb5, 0xb0, 0xf7, 0x18, 0x28, 0xce, 0x3e, 0xf0, 0x8c, 0x52, 0x5c, 0x51, 0x6a, 0xb1, 0x44, 0xc9,
        0x8c, 0xe6, 0x99, 0xbb, 0xae, 0x03, 0x92, 0x43, 0xf2, 0x89, 0xc9, 0x49, 0x55, 0x27, 0x31, 0x79,
        0xc6, 0x8a, 0x42, 0x2d, 0xa3, 0x97, 0x64, 0xb9, 0x2a, 0x26, 0x62, 0x9b, 0x83, 0xc9, 0xfb, 0xb8,
        0x6f, 0x1d, 0xa6, 0xa1, 0x2d, 0xaf, 0x70, 0xd5, 0x6f, 0x6a, 0x87, 0xd3, 0x6b, 0x74, 0xdd, 0x2f,
        0xb7, 0xe5, 0x7d, 0xac, 0x7a, 0x06, 0x94, 0xc0, 0x11, 0xad, 0xa3, 0x00, 0x07, 0x8b, 0xd6, 0x9a,
        0x79, 0x5b, 0x96, 0xc7, 0x18, 0xfa, 0x37, 0x34, 0x93, 0xce, 0xdb, 0x5a, 0xe1, 0x37, 0x30, 0x1f,
        0x6f, 0x6b, 0x40, 0xa4, 0x9b, 0x0a, 0x78, 0x9c, 0x95, 0xcc, 0x3d, 0x0a, 0xc3, 0x30, 0x0c, 0x40,
        0xe1, 0xdd, 0xa7, 0xd0, 0x5e, 0x28, 0xf2, 0x4f, 0x1c, 0x1b, 0x4a, 0xe8, 0x94, 0x03, 0xb4, 0x27,
        0x88, 0x1d, 0xa9, 0xcd, 0xe0, 0x06, 0x14, 0x05, 0x7a, 0xfc, 0x04, 0x7a, 0x82, 0x8e, 0x6f, 0xf8,
        0x9e, 0x0a, 0x11, 0x50, 0x9a, 0x7d, 0xf0, 0xe8, 0x9c, 0x0f, 0x58, 0x22, 0xf7, 0x9e, 0x63, 0xe1,
        0x98, 0xb1, 0xb3, 0xae, 0x86, 0x9a, 0x6a, 0x2c, 0x8e, 0x90, 0x6d, 0x36, 0xd3, 0xae, 0xef, 0x55,
        0xe0, 0xa9, 0xc4, 0xd3, 0x07, 0x1e, 0x74, 0x26, 0x09, 0xdc, 0x36, 0x15, 0xda, 0xef, 0xaf, 0xf6,
        0xbd, 0xce, 0x34, 0x80, 0xed, 0x63, 0x97, 0xec, 0x79, 0xcb, 0x70, 0x41, 0x8b, 0x68, 0xea, 0xda,
        0xda, 0xa2, 0x4a, 0x7f, 0x43, 0x33, 0x2e, 0xb2, 0x29, 0xfc, 0xbc, 0x39, 0x00, 0x59, 0x84, 0x33,
        0xb2, 0xbf, 0x27, 0x78, 0x9c, 0x5d, 0x52, 0x5b, 0x8a, 0xdd, 0x30, 0x0c, 0xfd, 0xf7, 0x2a, 0xb4,
        0x80, 0xe0, 0x4d, 0x74, 0x5a, 0x28, 0x94, 0x52, 0xe8, 0x0a, 0x74, 0x6d, 0x35, 0x23, 0x70, 0xec,
        0x8c, 0x64, 0xa5, 0xdb, 0xef, 0x71, 0x73, 0xfb, 0x84, 0x40, 0x64, 0x29, 0x3a, 0x2f, 0xe7, 0xd3,
        0x30, 0x39, 0x48, 0x4f, 0x8f, 0x83, 0xea, 0x68, 0xc3, 0xc8, 0x75, 0x12, 0x1f, 0x32, 0x37, 0x2a,
        0xa3, 0xbb, 0x94, 0x29, 0x33, 0xc4, 0x88, 0xab, 0x9e, 0xea, 0x45, 0xfb, 0x4e, 0xd2, 0x74, 0xe6,
        0xf4, 0x12, 0xea, 0xe4, 0x58, 0xbe, 0xd6, 0x79, 0xa3, 0x68, 0xd3, 0xb4, 0x88, 0xd3, 0x5a, 0xfd,
        0x26, 0x76, 0x48, 0x9f, 0x00, 0xe5, 0x28, 0x73, 0xd8, 0x46, 0xf6, 0x3a, 0x7a, 0x09, 0xa7, 0xc0,
        0xb4, 0xe9, 0x1e, 0x8d, 0x73, 0xfa, 0xf2, 0xca, 0x2e, 0xad, 0xa1, 0xcb, 0x93, 0xce, 0xb0, 0x58,
        0x80, 0xf5, 0x59, 0x95, 0x30, 0xc7, 0x4b, 0xb9, 0x44, 0x53, 0xcf, 0xe9, 0x6b, 0xf8, 0x29, 0xbd,
        0xaa, 0xbb, 0xfc, 0x81, 0x07, 0x06, 0x00, 0x50, 0x8a, 0xbf, 0x85, 0x80, 0x9a, 0xd8, 0x4a, 0xe4,
        0xf4, 0x11, 0xca, 0x6d, 0x2e, 0xb1, 0x4c, 0x5d, 0xbe, 0x03, 0x16, 0x9f, 0xf4, 0x22, 0x6b, 0xf2,
        0x8f, 0x2f, 0x88, 0xf9, 0x99, 0x80, 0x04, 0x8a, 0xc7, 0xc0, 0x0e, 0x0c, 0xec, 0xe2, 0x93, 0x7d,
        0xbb, 0x9d, 0xd1, 0xa8, 0x3a, 0x48, 0x8f, 0x53, 0xac, 0x2a, 0x08, 0xc4, 0x06, 0x46, 0xbf, 0x52,
        0x22, 0xe7, 0x5d, 0xe7, 0xda, 0xea, 0xd1, 0x0b, 0x1d, 0x4a, 0x5c, 0xc0, 0x08, 0x31, 0x50, 0x0c,
        0x2f, 0x7d, 0xf4, 0x3b, 0xdd, 0x9c, 0x3e, 0x47, 0x6b, 0xbc, 0xe2, 0xea, 0xd2, 0x79, 0x6d, 0xec,
        0xc6, 0x97, 0x56, 0xa6, 0x61, 0x45, 0x73, 0x7a, 0x17, 0xc6, 0x0f, 0x9d, 0x61, 0x37, 0x12, 0x43,
        0xf0, 0x0a, 0x15, 0x2b, 0x65, 0x18, 0xc8, 0x97, 0x9a, 0xed, 0x19, 0x27, 0x31, 0xaa, 0xa6, 0x6f,
        0x01, 0x3c, 0x46, 0xa0, 0x68, 0xe1, 0xc9, 0xe9, 0xfd, 0x54, 0x74, 0x7c, 0x54, 0x6e, 0xb8, 0x88,
        0x85, 0x0b, 0x2d, 0xe5, 0x77, 0xde, 0x4b, 0x10, 0x92, 0x06, 0x07, 0xae, 0x92, 0x2e, 0x9d, 0x2c,
        0x4f, 0x8f, 0x82, 0xcb, 0x3c, 0x46, 0xbd, 0x41, 0x65, 0xfe, 0x17, 0xeb, 0xa5, 0x97, 0x98, 0xf1,
        0xf3, 0x07, 0x59, 0x96, 0x96, 0xc4, 0x9c, 0x3e, 0x84, 0x17, 0xf9, 0xcb, 0xd0, 0xcd, 0x43, 0xda,
        0xe9, 0x94, 0x8a, 0x00, 0x5e, 0xc6, 0x62, 0x57, 0xc0, 0x58, 0x8d, 0xe5, 0xdc, 0xa7, 0x3e, 0xa2,
        0xa1, 0x6c, 0xfa, 0x40, 0x8e, 0x39, 0xfd, 0x00, 0xb4, 0xd2, 0xe8, 0x8d, 0xa4, 0x02, 0x78, 0x9c,
        0x33, 0x34, 0x30, 0x30, 0x33, 0x31, 0x51, 0x28, 0x49, 0x2d, 0x2e, 0xd1, 0x2b, 0xa9, 0x28, 0x61,
        0x98, 0xfe, 0xd3, 0x20, 0xe5, 0x4a, 0xad, 0x95, 0xca, 0xad, 0xc6, 0xaa, 0xbf, 0x7b, 0xb3, 0x9f,
        0x30, 0x0a, 0x4f, 0x6d, 0x7a, 0x04, 0x00, 0xf1, 0x1e, 0x0f, 0x5c, 0xa4, 0x02, 0x78, 0x9c, 0x33,
        0x34, 0x30, 0x30, 0x33, 0x31, 0x51, 0x28, 0x49, 0x2d, 0x2e, 0xd1, 0x2b, 0xa9, 0x28, 0x61, 0x10,
        0xeb, 0xd5, 0xd4, 0x6e, 0x9b, 0xff, 0xfc, 0xd3, 0xb1, 0xf8, 0x7f, 0x77, 0x8c, 0x1c, 0x5c, 0x1a,
        0x8f, 0x35, 0xc8, 0x99, 0x03, 0x00, 0xe7, 0xb7, 0x0e, 0x64, 0xfa, 0x01, 0x97, 0xf9, 0x30, 0x64,
        0xd4, 0x7d, 0x3a, 0x24, 0xda, 0x81, 0x7a, 0xfd, 0xbd, 0x6b, 0xe4, 0x01, 0x13, 0x95, 0x82, 0xe2,
        0x78, 0x9c, 0xfb, 0xcf, 0xd2, 0xc4, 0x3c, 0xe1, 0xba, 0x80, 0x6f, 0x62, 0x6a, 0x72, 0x6a, 0x5e,
        0x62, 0xb1, 0x42, 0x59, 0x66, 0x59, 0x6a, 0x51, 0x51, 0xe2, 0xc4, 0xf7, 0xb3, 0x01, 0x90, 0x80,
        0x0b, 0x57, 0xac, 0xf4, 0x5e, 0x7e, 0x44, 0x80, 0xd9, 0x85, 0x2d, 0x9a, 0xf3, 0x28, 0xc3, 0x01,
        0x25, 0x56, 0x76, 0xac, 0x28, 0xa4
    };

    // Set up packfile directory
    Ref<InternalDirectory> dir = InternalDirectory::create("dir");
    dir->addStream("xy.pack", *new ConstMemoryStream(REF_PACK_FILE));
    dir->addStream("xy.idx", *new ConstMemoryStream(REF_INDEX_FILE));

    // Set up testee with packfile
    server::file::InternalDirectoryHandler::Directory rootDir("");
    server::file::InternalDirectoryHandler rootHandler("root", rootDir);
    ObjectStore testee(rootHandler);
    testee.addNewPackFile(new server::file::ca::PackFile(*dir, "xy"));

    // Request existingobject
    static const ObjectId objId = {{ 0x16, 0x8d, 0x29, 0x2b, 0x86, 0x9f, 0xe7, 0xf2, 0xc6, 0x5f, 0xfe, 0xdc, 0x32, 0x40, 0x44, 0x81, 0xc6, 0x80, 0x1e, 0x37, }};
    Ref<FileMapping> obj = testee.getObject(objId, ObjectStore::DataObject);

    const char*const EXPECTED_CONTENT =
        "Lorem ipsum dolor sit amet, consectetuer adipiscing elit.\n"
        "Duis sem velit, ultrices et, fermentum auctor, rhoncus ut, ligula.\n"
        "Phasellus at purus sed purus cursus iaculis.\n"
        "Suspendisse fermentum.\n"
        "Pellentesque et arcu.\n"
        "Maecenas viverra.\n"
        "In consectetuer, lorem eu lobortis egestas, velit odio imperdiet eros, sit amet sagittis nunc mi ac neque.\n"
        "Sed non ipsum.\n"
        "Nullam venenatis gravida orci.\n";
    a.checkEqualContent("obj 1 content", obj->get(), afl::string::toBytes(EXPECTED_CONTENT));

    // Request nonexistant object
    static const ObjectId objId2 = {{ 0x44, 0x44, 0x44, 0x2b, 0x86, 0x9f, 0xe7, 0xf2, 0xc6, 0x5f, 0xfe, 0xdc, 0x32, 0x40, 0x44, 0x81, 0xc6, 0x80, 0x1e, 0x37, }};
    AFL_CHECK_THROWS(a("obj 2 fails"), testee.getObject(objId2, ObjectStore::DataObject), afl::except::FileProblemException);
}
