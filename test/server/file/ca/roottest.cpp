/**
  *  \file test/server/file/ca/roottest.cpp
  *  \brief Test for server::file::ca::Root
  */

#include "server/file/ca/root.hpp"

#include "afl/except/fileproblemexception.hpp"
#include "afl/io/internaldirectory.hpp"
#include "afl/io/internalfilesystem.hpp"
#include "afl/sys/log.hpp"
#include "afl/test/testrunner.hpp"
#include "server/file/directoryitem.hpp"
#include "server/file/filesystemhandler.hpp"
#include "server/file/internaldirectoryhandler.hpp"
#include "server/file/root.hpp"

using afl::io::FileSystem;
using server::file::DirectoryHandler;

namespace {
    // Packfiles for testing: git repository containing a single file "test.txt" containing "hallo\n".
    static const uint8_t INDEX_FILE[] = {
        0xff, 0x74, 0x4f, 0x63, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02,
        0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02,
        0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02,
        0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02,
        0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02,
        0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02,
        0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02,
        0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02,
        0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03,
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03,
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03,
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03,
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03,
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03,
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03,
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03,
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03,
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03,
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03,
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03,
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03,
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03,
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03,
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03,
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03,
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03,
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03,
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03,
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03,
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03,
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03,
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03,
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03,
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03,
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03,
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03,
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03,
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03,
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03,
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03,
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03,
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03,
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03,
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03,
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03,
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x15, 0xb8, 0x1f, 0xed, 0xbf, 0xef, 0x12, 0x34,
        0xab, 0x99, 0xcb, 0xbe, 0x51, 0x0a, 0x10, 0x13, 0xfa, 0x3f, 0xcc, 0x3c, 0x4c, 0xf5, 0xaa, 0x5f,
        0x9a, 0x64, 0x42, 0x63, 0xdb, 0xe3, 0xd6, 0xe7, 0x8b, 0xcb, 0xef, 0x45, 0x48, 0x7a, 0x80, 0x2c,
        0x6c, 0xc8, 0xfa, 0x1d, 0x7f, 0xf2, 0xf1, 0xc1, 0x89, 0xb0, 0x2a, 0xdb, 0x1b, 0xa1, 0x32, 0x82,
        0x03, 0x0e, 0xcb, 0x1e, 0x61, 0x9e, 0xbd, 0x4d, 0xe7, 0xd0, 0x2b, 0x13, 0x2e, 0x2d, 0x53, 0xe4,
        0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x84, 0x00, 0x00, 0x00, 0x93, 0xd8, 0x3b, 0xf3, 0xbb,
        0xe9, 0x2c, 0x48, 0x44, 0x41, 0xe3, 0xd4, 0x9b, 0xfb, 0x57, 0x6d, 0x67, 0x81, 0x82, 0xea, 0x15,
        0xef, 0x5f, 0x0f, 0x1f, 0x5e, 0x2e, 0x4a, 0xcf, 0x89, 0x4f, 0x96, 0xaa, 0xc1, 0xca, 0xd7, 0x28,
        0xf9, 0xfc, 0x3e, 0xa9
    };
    static const uint8_t PACK_FILE[] = {
        0x50, 0x41, 0x43, 0x4b, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x96, 0x0a, 0x78, 0x9c,
        0x95, 0xcb, 0x41, 0x0a, 0xc2, 0x30, 0x10, 0x00, 0xc0, 0x7b, 0x5e, 0xb1, 0x77, 0x41, 0x76, 0x13,
        0x9b, 0x44, 0x90, 0xe2, 0x1b, 0xda, 0x17, 0x6c, 0x92, 0x8d, 0x06, 0x4c, 0x0b, 0x71, 0x0b, 0x3e,
        0x5f, 0xbf, 0xe0, 0x71, 0x0e, 0xa3, 0x43, 0x04, 0x7c, 0xce, 0xb1, 0x32, 0x95, 0x50, 0xab, 0xad,
        0x94, 0x29, 0x5e, 0x13, 0x5a, 0x2e, 0x89, 0x12, 0x93, 0xb3, 0xd1, 0xa2, 0x43, 0xc9, 0x89, 0xc4,
        0xf0, 0xa1, 0xcf, 0x7d, 0xc0, 0xaa, 0x52, 0x79, 0x83, 0x45, 0x7e, 0x94, 0x01, 0xb7, 0xb7, 0x0e,
        0x39, 0xee, 0x8f, 0xfe, 0x39, 0x17, 0x99, 0x81, 0x82, 0x9f, 0xfc, 0xe4, 0x82, 0xbb, 0xc0, 0x09,
        0x09, 0xd1, 0xe4, 0xbd, 0xf7, 0xa6, 0x2a, 0x7f, 0x47, 0xd3, 0xb6, 0xa6, 0x8d, 0x5f, 0xe6, 0x0b,
        0xf8, 0x90, 0x32, 0xfd, 0x36, 0x78, 0x9c, 0xcb, 0x48, 0xcc, 0xc9, 0xc9, 0xe7, 0x02, 0x00, 0x08,
        0x37, 0x02, 0x1b, 0xa4, 0x02, 0x78, 0x9c, 0x33, 0x34, 0x30, 0x30, 0x33, 0x31, 0x51, 0x28, 0x49,
        0x2d, 0x2e, 0xd1, 0x2b, 0xa9, 0x28, 0x61, 0xf0, 0xf9, 0xba, 0x2a, 0x7e, 0x56, 0x8a, 0x53, 0xf2,
        0xed, 0xc7, 0xd7, 0x9e, 0x77, 0x9f, 0x7e, 0xef, 0xea, 0x51, 0xd5, 0xa0, 0x03, 0x00, 0xfb, 0x44,
        0x0f, 0xfe, 0xd8, 0x3b, 0xf3, 0xbb, 0xe9, 0x2c, 0x48, 0x44, 0x41, 0xe3, 0xd4, 0x9b, 0xfb, 0x57,
        0x6d, 0x67, 0x81, 0x82, 0xea, 0x15
    };

    size_t countObjects(server::file::InternalDirectoryHandler& dir)
    {
        server::file::InternalDirectoryHandler::Directory* objDir = dir.findDirectory("objects");
        size_t count = 0;
        if (objDir != 0) {
            for (size_t i = 0, n = objDir->subdirectories.size(); i < n; ++i) {
                count += objDir->subdirectories[i]->files.size();
            }
        }
        return count;
    }
}


/** Test operation on initially-empty directory. */
AFL_TEST("server.file.ca.Root:empty", a)
{
    // Storage
    server::file::InternalDirectoryHandler::Directory rootDir("");
    server::file::InternalDirectoryHandler rootHandler("root", rootDir);
    afl::sys::Log log;

    // Store some files
    {
        server::file::ca::Root t(rootHandler, log);
        a.checkEqual("01. getMasterCommitId", t.getMasterCommitId(), server::file::ca::ObjectId::nil);

        server::file::DirectoryItem rootItem("(ca-root)", 0, std::auto_ptr<server::file::DirectoryHandler>(t.createRootHandler()));
        rootItem.createDirectory("d");
        rootItem.createFile("f", afl::string::toBytes("text"));
    }

    // Retrieve files
    {
        server::file::ca::Root t(rootHandler, log);
        server::file::DirectoryItem rootItem("(ca-root)", 0, std::auto_ptr<server::file::DirectoryHandler>(t.createRootHandler()));
        server::file::Root root(rootItem, afl::io::InternalDirectory::create("x"));
        rootItem.readContent(root);

        // Directory
        a.checkNonNull("11. findDirectory", rootItem.findDirectory("d"));

        // File
        server::file::FileItem* fi = rootItem.findFile("f");
        a.checkNonNull("21. findFile", fi);
        a.check("22. file size", rootItem.getFileContent(*fi)->get().equalContent(afl::string::toBytes("text")));
    }
}

/** Test operation with a preloaded image. */
AFL_TEST("server.file.ca.Root:preloaded", a)
{
    // Storage
    server::file::InternalDirectoryHandler::Directory rootDir("");
    server::file::InternalDirectoryHandler rootHandler("root", rootDir);
    afl::sys::Log log;

    // Preload
    {
        std::auto_ptr<DirectoryHandler> refs(rootHandler.getDirectory(rootHandler.createDirectory("refs")));
        std::auto_ptr<DirectoryHandler> heads(refs->getDirectory(refs->createDirectory("heads")));
        heads->createFile("master", afl::string::toBytes("1ec5873554c8cd604036b4b6c0221a5ded967637\n"));

        std::auto_ptr<DirectoryHandler> tags(refs->getDirectory(refs->createDirectory("tags")));
        tags->createFile("snapshot", afl::string::toBytes("1ec5873554c8cd604036b4b6c0221a5ded967637\n"));
    }
    {
        std::auto_ptr<DirectoryHandler> objs(rootHandler.getDirectory(rootHandler.createDirectory("objects")));

        static const uint8_t obj1e[] = {
            0x78, 0x01, 0x95, 0x8d, 0x51, 0x0a, 0x42, 0x21, 0x10, 0x45, 0xfb, 0x76,
            0x15, 0xf3, 0x1f, 0x84, 0x3e, 0xed, 0xa9, 0x10, 0xd1, 0x1a, 0x6a, 0x05,
            0xa3, 0x33, 0x96, 0x90, 0xef, 0x81, 0xcd, 0x83, 0x96, 0x9f, 0xd4, 0x0a,
            0xfa, 0xbc, 0x70, 0xce, 0xb9, 0x79, 0x6d, 0xad, 0x0a, 0x18, 0x6f, 0x77,
            0xd2, 0x99, 0x21, 0x22, 0xfa, 0xec, 0x22, 0x4e, 0x9e, 0x48, 0x6b, 0xa2,
            0x29, 0x51, 0x8a, 0x99, 0xed, 0xd1, 0x95, 0x88, 0x73, 0xc8, 0x45, 0x3b,
            0x1b, 0xe7, 0x14, 0x15, 0x6e, 0xf2, 0x58, 0x3b, 0xdc, 0x84, 0x0b, 0x2e,
            0x70, 0xe5, 0x31, 0xb9, 0xc3, 0xe9, 0x35, 0x2a, 0xdb, 0xe5, 0xde, 0xde,
            0x07, 0xe2, 0x33, 0x18, 0x17, 0x82, 0x35, 0xc6, 0x79, 0x0f, 0x7b, 0x6d,
            0xb4, 0x56, 0xf9, 0x7b, 0x27, 0x83, 0xfc, 0x53, 0x54, 0x75, 0xa9, 0x52,
            0xf1, 0x09, 0xbf, 0x82, 0xfa, 0x00, 0xb0, 0x30, 0x38, 0xdc
        };
        std::auto_ptr<DirectoryHandler> p(objs->getDirectory(objs->createDirectory("1e")));
        p->createFile("c5873554c8cd604036b4b6c0221a5ded967637", obj1e);

        static const uint8_t obj39[] = {
            0x78, 0x01, 0x2b, 0x29, 0x4a, 0x4d, 0x55, 0x30, 0x36, 0x62, 0x30, 0x34,
            0x30, 0x30, 0x33, 0x31, 0x51, 0x48, 0xcb, 0xcc, 0x49, 0x65, 0x70, 0x10,
            0xd1, 0xe5, 0x3c, 0xae, 0xad, 0xa3, 0x1a, 0xce, 0x3d, 0xc3, 0x80, 0x47,
            0xfd, 0xc6, 0x9c, 0xf0, 0xb7, 0xc2, 0xba, 0x00, 0xd7, 0x51, 0x0b, 0x47
        };
        p.reset(objs->getDirectory(objs->createDirectory("39")));
        p->createFile("7bbf059739cbfa73aad2f8bf404d04f478b38a", obj39);

        static const uint8_t obj40[] = {
            0x78, 0x01, 0x4b, 0xca, 0xc9, 0x4f, 0x52, 0x30, 0x65, 0x48, 0xca, 0x29,
            0x4d, 0xe2, 0x02, 0x00, 0x19, 0x4a, 0x03, 0xa4
        };
        p.reset(objs->getDirectory(objs->createDirectory("40")));
        p->createFile("142d09c72b2c25570b98300c27d89c57ed132d", obj40);

        static const uint8_t obj9a[] = {
            0x78, 0x01, 0x2b, 0x29, 0x4a, 0x4d, 0x55, 0x30, 0x33, 0x62, 0x30, 0x31,
            0x00, 0x02, 0x85, 0x94, 0xcc, 0x22, 0x06, 0xcb, 0xea, 0xfd, 0xac, 0xd3,
            0x2d, 0x4f, 0xff, 0x2a, 0x5e, 0x75, 0xe9, 0xc7, 0x7e, 0x07, 0x5f, 0x96,
            0x2f, 0x15, 0x9b, 0xbb, 0x0c, 0x0d, 0x0c, 0xcc, 0x4c, 0x4c, 0x14, 0xd2,
            0x32, 0x73, 0x52, 0x19, 0x96, 0xff, 0xb8, 0xf9, 0xf4, 0xce, 0xe7, 0x65,
            0xfd, 0x77, 0xb5, 0x7f, 0x17, 0xd5, 0xdc, 0x13, 0x62, 0x9a, 0x51, 0xaa,
            0xc6, 0x0d, 0x00, 0xc6, 0x68, 0x1d, 0xea
        };
        p.reset(objs->getDirectory(objs->createDirectory("9a")));
        p->createFile("a7c49a27dd00dd2bdb9ce354f9a68cf04396b9", obj9a);

        static const uint8_t obja7[] = {
            0x78, 0x01, 0x4b, 0xca, 0xc9, 0x4f, 0x52, 0x30, 0x61, 0x48, 0xca, 0x49,
            0xe4, 0x02, 0x00, 0x15, 0x20, 0x03, 0x2d
        };
        p.reset(objs->getDirectory(objs->createDirectory("a7")));
        p->createFile("f8d9e5dcf3a68fdd2bfb727cde12029875260b", obja7);
    }

    // Access it
    server::file::ca::Root t(rootHandler, log);
    server::file::DirectoryItem rootItem("(ca-root)", 0, std::auto_ptr<server::file::DirectoryHandler>(t.createRootHandler()));
    server::file::Root root(rootItem, afl::io::InternalDirectory::create("x"));
    rootItem.readContent(root);

    // File
    server::file::FileItem* fi = rootItem.findFile("file");
    a.checkNonNull("01. findFile", fi);
    a.check("02. file content", rootItem.getFileContent(*fi)->get().equalContent(afl::string::toBytes("bla\n")));

    // Directory
    server::file::DirectoryItem* di = rootItem.findDirectory("dir");
    a.checkNonNull("11. findDirectory", di);

    // Subdirectory
    di->readContent(root);
    fi = di->findFile("file");
    a.checkNonNull("21. findFile", fi);
    a.check("22. file content", rootItem.getFileContent(*fi)->get().equalContent(afl::string::toBytes("blub\n")));

    // Snapshots
    afl::data::StringList_t snapshotList;
    t.listSnapshots(snapshotList);
    a.checkEqual("31. num snapshots", snapshotList.size(), 1U);
    a.checkEqual("32. snapshot name", snapshotList[0], "snapshot");

    a.checkEqual("33. snapshot content", t.getSnapshotCommitId("snapshot").orElse(server::file::ca::ObjectId::nil).toHex(), "1ec5873554c8cd604036b4b6c0221a5ded967637");
    a.checkEqual("34. missing snapshot", t.getSnapshotCommitId("other").isValid(), false);
}

/** Test garbage cleanup. */
AFL_TEST("server.file.ca.Root:garbage", a)
{
    // Storage
    server::file::InternalDirectoryHandler::Directory rootDir("");
    server::file::InternalDirectoryHandler rootHandler("root", rootDir);
    afl::sys::Log log;
    server::file::ca::Root testee(rootHandler, log);

    // Create stuff
    std::auto_ptr<DirectoryHandler> root(testee.createRootHandler());
    std::auto_ptr<DirectoryHandler> dir1(root->getDirectory(root->createDirectory("dir1")));
    std::auto_ptr<DirectoryHandler> dir2(root->getDirectory(root->createDirectory("dir2")));
    dir1->createFile("a", afl::string::toBytes("content"));
    dir2->createFile("a", afl::string::toBytes("content"));

    // Verify content.
    // 'objects' must have one DataObject, two TreeObject's, and one CommitObject.
    a.checkEqual("01", countObjects(rootHandler), 4U);

    // Update a file.
    // Must now have two DataObject's, three TreeObject's, and one CommitObject.
    dir2->createFile("a", afl::string::toBytes("newcontent"));
    a.checkEqual("11", countObjects(rootHandler), 6U);

    // Update other file. This will merge again.
    dir1->createFile("a", afl::string::toBytes("newcontent"));
    a.checkEqual("21", countObjects(rootHandler), 4U);
}

/** Test creating/garbage-collecting snapshots. */
AFL_TEST("server.file.ca.Root:garbage:snapshot:remove", a)
{
    // Storage
    server::file::InternalDirectoryHandler::Directory rootDir("");
    server::file::InternalDirectoryHandler rootHandler("root", rootDir);
    afl::sys::Log log;
    server::file::ca::Root testee(rootHandler, log);

    // Create stuff
    std::auto_ptr<DirectoryHandler> root(testee.createRootHandler());
    std::auto_ptr<DirectoryHandler> dir1(root->getDirectory(root->createDirectory("dir1")));
    std::auto_ptr<DirectoryHandler> dir2(root->getDirectory(root->createDirectory("dir2")));
    dir1->createFile("a", afl::string::toBytes("content"));
    dir2->createFile("a", afl::string::toBytes("content"));

    // Verify content.
    // 'objects' must have one DataObject, two TreeObject's, and one CommitObject.
    a.checkEqual("01", countObjects(rootHandler), 4U);

    // Create a snapshot
    testee.setSnapshotCommitId("t", testee.getMasterCommitId());
    a.checkEqual("02", countObjects(rootHandler), 4U);

    // Update a file.
    // Must now have two DataObject's, four TreeObject's, and two CommitObject's.
    dir2->createFile("a", afl::string::toBytes("newcontent"));
    a.checkEqual("11", countObjects(rootHandler), 8U);

    // Update other file. This will merge again, but keep the old data.
    dir1->createFile("a", afl::string::toBytes("newcontent"));
    a.checkEqual("21", countObjects(rootHandler), 8U);

    // Must have two roots here (master and tag)
    std::vector<server::file::ca::ObjectId> roots;
    testee.listRoots(roots);
    a.checkEqual("22", roots.size(), 2U);

    // Remove the snapshot. This will remove old stuff.
    testee.removeSnapshot("t");
    a.checkEqual("31", countObjects(rootHandler), 4U);
}

/** Test creating/garbage-collecting snapshots.
    Same thing as previous, but instead of removing the snapshot, point it to master. */
AFL_TEST("server.file.ca.Root:garbage:snapshot:change", a)
{
    // Storage
    server::file::InternalDirectoryHandler::Directory rootDir("");
    server::file::InternalDirectoryHandler rootHandler("root", rootDir);
    afl::sys::Log log;
    server::file::ca::Root testee(rootHandler, log);

    // Create stuff
    std::auto_ptr<DirectoryHandler> root(testee.createRootHandler());
    std::auto_ptr<DirectoryHandler> dir1(root->getDirectory(root->createDirectory("dir1")));
    std::auto_ptr<DirectoryHandler> dir2(root->getDirectory(root->createDirectory("dir2")));
    dir1->createFile("a", afl::string::toBytes("content"));
    dir2->createFile("a", afl::string::toBytes("content"));

    // Verify content.
    // 'objects' must have one DataObject, two TreeObject's, and one CommitObject.
    a.checkEqual("01", countObjects(rootHandler), 4U);

    // Create a snapshot
    testee.setSnapshotCommitId("t", testee.getMasterCommitId());
    a.checkEqual("02", countObjects(rootHandler), 4U);

    // Update a file.
    // Must now have two DataObject's, four TreeObject's, and two CommitObject's.
    dir2->createFile("a", afl::string::toBytes("newcontent"));
    a.checkEqual("11", countObjects(rootHandler), 8U);

    // Update other file. This will merge again, but keep the old data.
    dir1->createFile("a", afl::string::toBytes("newcontent"));
    a.checkEqual("21", countObjects(rootHandler), 8U);

    // Move the snapshot. This will remove old stuff.
    testee.setSnapshotCommitId("t", testee.getMasterCommitId());

    // Verify content
    afl::base::Ref<afl::io::FileMapping> content1 = dir1->getFileByName("a");
    a.checkEqualContent("42", content1->get(), afl::string::toBytes("newcontent"));
    a.checkEqual("31", countObjects(rootHandler), 4U);
}

/** Test reverting the master commit. */
AFL_TEST("server.file.ca.Root:garbage:snapshot:change-revert", a)
{
    // Storage
    server::file::InternalDirectoryHandler::Directory rootDir("");
    server::file::InternalDirectoryHandler rootHandler("root", rootDir);
    afl::sys::Log log;
    server::file::ca::Root testee(rootHandler, log);

    // Create stuff
    std::auto_ptr<DirectoryHandler> root(testee.createRootHandler());
    std::auto_ptr<DirectoryHandler> dir1(root->getDirectory(root->createDirectory("dir1")));
    std::auto_ptr<DirectoryHandler> dir2(root->getDirectory(root->createDirectory("dir2")));
    dir1->createFile("a", afl::string::toBytes("content"));
    dir2->createFile("a", afl::string::toBytes("content"));

    // Verify content.
    // 'objects' must have one DataObject, two TreeObject's, and one CommitObject.
    a.checkEqual("01", countObjects(rootHandler), 4U);

    // Create a snapshot
    server::file::ca::ObjectId oldMaster = testee.getMasterCommitId();
    testee.setSnapshotCommitId("t", oldMaster);
    a.checkEqual("02", countObjects(rootHandler), 4U);

    // Update a file.
    // Must now have two DataObject's, four TreeObject's, and two CommitObject's.
    dir2->createFile("a", afl::string::toBytes("newcontent"));
    a.checkEqual("11", countObjects(rootHandler), 8U);

    // Update other file. This will merge again, but keep the old data.
    dir1->createFile("a", afl::string::toBytes("newcontent"));
    a.checkEqual("21", countObjects(rootHandler), 8U);

    // Move master commit. This will remove old stuff.
    testee.setMasterCommitId(oldMaster);
    a.checkEqual("31", countObjects(rootHandler), 4U);

    // Verify content
    // Recreate all the objects because live-change of master may not be supported.
    std::auto_ptr<DirectoryHandler> newRoot(testee.createRootHandler());
    DirectoryHandler::Info dir1Info;
    a.check("41", newRoot->findItem("dir1", dir1Info));

    std::auto_ptr<DirectoryHandler> newDir1(newRoot->getDirectory(dir1Info));
    afl::base::Ref<afl::io::FileMapping> content1 = newDir1->getFileByName("a");
    a.checkEqualContent("42", content1->get(), afl::string::toBytes("content"));
}

/** Test snapshot handling interface. */
AFL_TEST("server.file.ca.Root:garbage:snapshot:handler", a)
{
    // Storage
    server::file::InternalDirectoryHandler::Directory rootDir("");
    server::file::InternalDirectoryHandler rootHandler("root", rootDir);
    afl::sys::Log log;
    server::file::ca::Root testee(rootHandler, log);

    // Create stuff
    std::auto_ptr<DirectoryHandler> root(testee.createRootHandler());
    std::auto_ptr<DirectoryHandler> dir(root->getDirectory(root->createDirectory("dir1")));

    // Access snapshot handler: root has one, dir has none
    DirectoryHandler::SnapshotHandler* rootSnap = root->getSnapshotHandler();
    DirectoryHandler::SnapshotHandler* dirSnap = dir->getSnapshotHandler();
    a.checkNonNull("01. root snap", rootSnap);
    a.checkNull("02. dir snap", dirSnap);

    // Exercise methods
    rootSnap->createSnapshot("a");
    rootSnap->copySnapshot("a", "b");
    rootSnap->removeSnapshot("a");

    afl::data::StringList_t list;
    rootSnap->listSnapshots(list);
    a.checkEqual("11. num snaps", list.size(), 1U);
    a.checkEqual("12. snap name", list[0], "b");

    // Error case: snapshot not found
    AFL_CHECK_THROWS(a("21. bad snap"), rootSnap->copySnapshot("x", "y"), std::runtime_error);
}

/** Test tree access. */
AFL_TEST("server.file.ca.Root:tree-access", a)
{
    // Storage
    server::file::InternalDirectoryHandler::Directory rootDir("");
    server::file::InternalDirectoryHandler rootHandler("root", rootDir);
    afl::sys::Log log;
    server::file::ca::Root testee(rootHandler, log);

    // Create stuff
    std::auto_ptr<DirectoryHandler> root(testee.createRootHandler());
    root->createFile("a", afl::string::toBytes("first"));
    testee.setSnapshotCommitId("t", testee.getMasterCommitId());
    root->createFile("a", afl::string::toBytes("second"));

    // Must have 6 items (2 commits, 2 trees, 2 blobs)
    a.checkEqual("01", countObjects(rootHandler), 6U);

    // Access tag data
    afl::base::Optional<server::file::ca::ObjectId> snapId = testee.getSnapshotCommitId("t");
    a.check("11", snapId.isValid());
    std::auto_ptr<DirectoryHandler> snap(testee.createSnapshotHandler(*snapId.get()));
    afl::base::Ref<afl::io::FileMapping> snapContent = snap->getFileByName("a");
    a.checkEqualContent("12", snapContent->get(), afl::string::toBytes("first"));
    AFL_CHECK_THROWS(a("13. createDirectory"), snap->createDirectory("x"), afl::except::FileProblemException);

    // Access master data
    std::auto_ptr<DirectoryHandler> master(testee.createSnapshotHandler(testee.getMasterCommitId()));
    afl::base::Ref<afl::io::FileMapping> masterContent = master->getFileByName("a");
    a.checkEqualContent("21", masterContent->get(), afl::string::toBytes("second"));
    AFL_CHECK_THROWS(a("22. createDirectory"), master->createDirectory("x"), afl::except::FileProblemException);
}

/** Test packed repository handling. */
AFL_TEST("server.file.ca.Root:packed", a)
{
    // Populate file system
    afl::io::InternalFileSystem fs;
    fs.createDirectory("/repo");
    fs.createDirectory("/repo/objects");
    fs.createDirectory("/repo/objects/pack");
    fs.openFile("/repo/objects/pack/pack-d83bf3bbe92c484441e3d49bfb576d678182ea15.idx", FileSystem::Create)
        ->fullWrite(INDEX_FILE);
    fs.openFile("/repo/objects/pack/pack-d83bf3bbe92c484441e3d49bfb576d678182ea15.pack", FileSystem::Create)
        ->fullWrite(PACK_FILE);
    fs.openFile("/repo/packed-refs", FileSystem::Create)
        ->fullWrite(afl::string::toBytes("# pack-refs with: peeled fully-peeled sorted \n"
                                         "15b81fedbfef1234ab99cbbe510a1013fa3fcc3c refs/heads/master\n"
                                         "15b81fedbfef1234ab99cbbe510a1013fa3fcc3c refs/tags/snap\n"));

    // Test setup
    server::file::FileSystemHandler root(fs, "/repo");
    afl::sys::Log log;
    server::file::ca::Root testee(root, log);

    // Verify
    a.checkEqual("matching master commit ID", testee.getMasterCommitId().toHex(), "15b81fedbfef1234ab99cbbe510a1013fa3fcc3c");

    a.check("has tag commit ID", testee.getSnapshotCommitId("snap").isValid());
    a.checkEqual("matching tag commit ID", testee.getSnapshotCommitId("snap").get()->toHex(), "15b81fedbfef1234ab99cbbe510a1013fa3fcc3c");

    // Use it
    std::auto_ptr<server::file::DirectoryHandler> hdl(testee.createRootHandler());
    a.checkNonNull("must have created a root handler", hdl.get());

    afl::base::Ref<afl::io::FileMapping> map = hdl->getFileByName("test.txt");
    a.checkEqual("must have correct content", afl::string::fromBytes(map->get()), "hallo\n");

    // Check that packed-refs file is gone
    AFL_CHECK_THROWS(a("must have removed packed-refs"), fs.openFile("/repo/packed-refs", FileSystem::OpenRead), afl::except::FileProblemException);
}

/** Test packed repository handling, erroneous files.
    The erroneous files shall not prevent the creation of the file from proceeding. */
AFL_TEST("server.file.ca.Root:packed:errors", a)
{
    static const uint8_t BAD[] = {1,2,3,4,5};

    // Populate file system
    afl::io::InternalFileSystem fs;
    fs.createDirectory("/repo");
    fs.createDirectory("/repo/objects");
    fs.createDirectory("/repo/objects/pack");
    fs.openFile("/repo/objects/pack/aaa.idx", FileSystem::Create)
        ->fullWrite(BAD);
    fs.openFile("/repo/objects/pack/aaa.pack", FileSystem::Create)
        ->fullWrite(BAD);
    fs.openFile("/repo/objects/pack/pack-d83bf3bbe92c484441e3d49bfb576d678182ea15.idx", FileSystem::Create)
        ->fullWrite(INDEX_FILE);
    fs.openFile("/repo/objects/pack/pack-d83bf3bbe92c484441e3d49bfb576d678182ea15.pack", FileSystem::Create)
        ->fullWrite(PACK_FILE);
    fs.openFile("/repo/objects/pack/zzz.idx", FileSystem::Create)
        ->fullWrite(BAD);
    fs.openFile("/repo/objects/pack/zzz.pack", FileSystem::Create)
        ->fullWrite(BAD);
    fs.openFile("/repo/packed-refs", FileSystem::Create)
        ->fullWrite(afl::string::toBytes("# pack-refs with: peeled fully-peeled sorted \n"
                                         "15b81fedbfef1234ab99cbbe510a1013fa3fcc3c refs/heads/master\n"
                                         "15b81fedbfef1234ab99cbbe510a1013fa3fcc3c refs/tags/snap\n"));

    // Test setup
    server::file::FileSystemHandler root(fs, "/repo");
    afl::sys::Log log;
    server::file::ca::Root testee(root, log);

    // Verify
    a.checkEqual("matching master commit ID", testee.getMasterCommitId().toHex(), "15b81fedbfef1234ab99cbbe510a1013fa3fcc3c");

    a.check("has tag commit ID", testee.getSnapshotCommitId("snap").isValid());
    a.checkEqual("matching tag commit ID", testee.getSnapshotCommitId("snap").get()->toHex(), "15b81fedbfef1234ab99cbbe510a1013fa3fcc3c");

    // Use it
    std::auto_ptr<server::file::DirectoryHandler> hdl(testee.createRootHandler());
    a.checkNonNull("must have created a root handler", hdl.get());

    afl::base::Ref<afl::io::FileMapping> map = hdl->getFileByName("test.txt");
    a.checkEqual("must have correct content", afl::string::fromBytes(map->get()), "hallo\n");

    // Check that packed-refs file is gone
    AFL_CHECK_THROWS(a("must have removed packed-refs"), fs.openFile("/repo/packed-refs", FileSystem::OpenRead), afl::except::FileProblemException);
}
